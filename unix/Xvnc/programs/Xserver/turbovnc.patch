diff --git a/xorg-server-1.19.7/Xext/saver.c b/Xserver/Xext/saver.c
index 45ac4d2..26321af 100644
--- a/xorg-server-1.19.7/Xext/saver.c
+++ b/Xserver/Xext/saver.c
@@ -1050,7 +1050,7 @@ ScreenSaverSetAttributes(ClientPtr client)
         pVlist++;
     }
     if (pPriv->attr)
-        FreeScreenAttr(pPriv->attr);
+        FreeResource(pPriv->attr->resource, AttrType);
     pPriv->attr = pAttr;
     pAttr->resource = FakeClientID(client->index);
     if (!AddResource(pAttr->resource, AttrType, (void *) pAttr))
diff --git a/xorg-server-1.19.7/Xext/xtest.c b/Xserver/Xext/xtest.c
index 2371a69..8cba7c6 100644
--- a/xorg-server-1.19.7/Xext/xtest.c
+++ b/Xserver/Xext/xtest.c
@@ -501,10 +501,11 @@ XTestSwapFakeInput(ClientPtr client, xReq * req)
 
     nev = ((req->length << 2) - sizeof(xReq)) / sizeof(xEvent);
     for (ev = (xEvent *) &req[1]; --nev >= 0; ev++) {
+        int evtype = ev->u.u.type & 0x177;
         /* Swap event */
-        proc = EventSwapVector[ev->u.u.type & 0177];
+        proc = EventSwapVector[evtype];
         /* no swapping proc; invalid event type? */
-        if (!proc || proc == NotImplemented) {
+        if (!proc || proc == NotImplemented || evtype == GenericEvent) {
             client->errorValue = ev->u.u.type;
             return BadValue;
         }
diff --git a/xorg-server-1.19.7/Xext/xvmain.c b/Xserver/Xext/xvmain.c
index c9b11d4..7c85710 100644
--- a/xorg-server-1.19.7/Xext/xvmain.c
+++ b/Xserver/Xext/xvmain.c
@@ -811,8 +811,10 @@ XvdiSelectVideoNotify(ClientPtr client, DrawablePtr pDraw, BOOL onoff)
         tpn = pn;
         while (tpn) {
             if (tpn->client == client) {
-                if (!onoff)
+                if (!onoff) {
                     tpn->client = NULL;
+                    FreeResource(tpn->id, XvRTVideoNotify);
+                }
                 return Success;
             }
             if (!tpn->client)
diff --git a/xorg-server-1.19.7/Xi/exevents.c b/Xserver/Xi/exevents.c
index 17d751e..accc810 100644
--- a/xorg-server-1.19.7/Xi/exevents.c
+++ b/Xserver/Xi/exevents.c
@@ -561,22 +561,25 @@ DeepCopyPointerClasses(DeviceIntPtr from, DeviceIntPtr to)
                 to->button = calloc(1, sizeof(ButtonClassRec));
                 if (!to->button)
                     FatalError("[Xi] no memory for class shift.\n");
+                to->button->numButtons = from->button->numButtons;
             }
             else
                 classes->button = NULL;
         }
 
         if (from->button->xkb_acts) {
-            if (!to->button->xkb_acts) {
-                to->button->xkb_acts = calloc(1, sizeof(XkbAction));
-                if (!to->button->xkb_acts)
-                    FatalError("[Xi] not enough memory for xkb_acts.\n");
-            }
+            size_t maxbuttons = max(to->button->numButtons, from->button->numButtons);
+            to->button->xkb_acts = xnfreallocarray(to->button->xkb_acts,
+                                                   maxbuttons,
+                                                   sizeof(XkbAction));
+            memset(to->button->xkb_acts, 0, maxbuttons * sizeof(XkbAction));
             memcpy(to->button->xkb_acts, from->button->xkb_acts,
-                   sizeof(XkbAction));
+                   from->button->numButtons * sizeof(XkbAction));
         }
-        else
+        else {
             free(to->button->xkb_acts);
+            to->button->xkb_acts = NULL;
+        }
 
         memcpy(to->button->labels, from->button->labels,
                from->button->numButtons * sizeof(Atom));
diff --git a/xorg-server-1.19.7/Xi/xichangehierarchy.c b/Xserver/Xi/xichangehierarchy.c
index 7286eff..bf68bac 100644
--- a/xorg-server-1.19.7/Xi/xichangehierarchy.c
+++ b/Xserver/Xi/xichangehierarchy.c
@@ -140,7 +140,7 @@ add_master(ClientPtr client, xXIAddMasterInfo * c, int flags[MAXDEVICES])
 {
     DeviceIntPtr ptr, keybd, XTestptr, XTestkeybd;
     char *name;
-    int rc;
+    int i, rc;
 
     name = calloc(c->name_len + 1, sizeof(char));
     if (name == NULL) {
@@ -194,7 +194,7 @@ add_master(ClientPtr client, xXIAddMasterInfo * c, int flags[MAXDEVICES])
     flags[XTestptr->id] |= XISlaveAttached;
     flags[XTestkeybd->id] |= XISlaveAttached;
 
-    for (int i = 0; i < currentMaxClients; i++)
+    for (i = 0; i < currentMaxClients; i++)
         XIBarrierNewMasterDevice(clients[i], ptr->id);
 
  unwind:
@@ -219,7 +219,7 @@ static int
 remove_master(ClientPtr client, xXIRemoveMasterInfo * r, int flags[MAXDEVICES])
 {
     DeviceIntPtr ptr, keybd, XTestptr, XTestkeybd;
-    int rc = Success;
+    int i, rc = Success;
 
     if (r->return_mode != XIAttachToMaster && r->return_mode != XIFloating)
         return BadValue;
@@ -301,7 +301,7 @@ remove_master(ClientPtr client, xXIRemoveMasterInfo * r, int flags[MAXDEVICES])
         }
     }
 
-    for (int i = 0; i < currentMaxClients; i++)
+    for (i = 0; i < currentMaxClients; i++)
         XIBarrierRemoveMasterDevice(clients[i], ptr->id);
 
     /* disable the remove the devices, XTest devices must be done first
@@ -416,6 +416,11 @@ ProcXIChangeHierarchy(ClientPtr client)
     size_t len;			/* length of data remaining in request */
     int rc = Success;
     int flags[MAXDEVICES] = { 0 };
+    enum {
+        NO_CHANGE,
+        FLUSH,
+        CHANGED,
+    } changes = NO_CHANGE;
 
     REQUEST(xXIChangeHierarchyReq);
     REQUEST_AT_LEAST_SIZE(xXIChangeHierarchyReq);
@@ -423,7 +428,7 @@ ProcXIChangeHierarchy(ClientPtr client)
     if (!stuff->num_changes)
         return rc;
 
-    len = ((size_t)stuff->length << 2) - sizeof(xXIChangeHierarchyReq);
+    len = ((size_t)client->req_len << 2) - sizeof(xXIChangeHierarchyReq);
 
     any = (xXIAnyHierarchyChangeInfo *) &stuff[1];
     while (stuff->num_changes--) {
@@ -465,8 +470,9 @@ ProcXIChangeHierarchy(ClientPtr client)
             rc = add_master(client, c, flags);
             if (rc != Success)
                 goto unwind;
-        }
+            changes = FLUSH;
             break;
+        }
         case XIRemoveMaster:
         {
             xXIRemoveMasterInfo *r = (xXIRemoveMasterInfo *) any;
@@ -475,8 +481,9 @@ ProcXIChangeHierarchy(ClientPtr client)
             rc = remove_master(client, r, flags);
             if (rc != Success)
                 goto unwind;
-        }
+            changes = FLUSH;
             break;
+        }
         case XIDetachSlave:
         {
             xXIDetachSlaveInfo *c = (xXIDetachSlaveInfo *) any;
@@ -485,8 +492,9 @@ ProcXIChangeHierarchy(ClientPtr client)
             rc = detach_slave(client, c, flags);
             if (rc != Success)
                 goto unwind;
-        }
+            changes = CHANGED;
             break;
+        }
         case XIAttachSlave:
         {
             xXIAttachSlaveInfo *c = (xXIAttachSlaveInfo *) any;
@@ -495,16 +503,25 @@ ProcXIChangeHierarchy(ClientPtr client)
             rc = attach_slave(client, c, flags);
             if (rc != Success)
                 goto unwind;
+            changes = CHANGED;
+            break;
         }
+        default:
             break;
         }
 
+        if (changes == FLUSH) {
+            XISendDeviceHierarchyEvent(flags);
+            memset(flags, 0, sizeof(flags));
+            changes = NO_CHANGE;
+        }
+
         len -= any->length * 4;
         any = (xXIAnyHierarchyChangeInfo *) ((char *) any + any->length * 4);
     }
 
  unwind:
-
-    XISendDeviceHierarchyEvent(flags);
+    if (changes != NO_CHANGE)
+        XISendDeviceHierarchyEvent(flags);
     return rc;
 }
diff --git a/xorg-server-1.19.7/Xi/xipassivegrab.c b/Xserver/Xi/xipassivegrab.c
index 9241ffd..c702d6b 100644
--- a/xorg-server-1.19.7/Xi/xipassivegrab.c
+++ b/Xserver/Xi/xipassivegrab.c
@@ -93,6 +93,7 @@ ProcXIPassiveGrabDevice(ClientPtr client)
     GrabParameters param;
     void *tmp;
     int mask_len;
+    uint32_t length;
 
     REQUEST(xXIPassiveGrabDeviceReq);
     REQUEST_FIXED_SIZE(xXIPassiveGrabDeviceReq,
@@ -133,6 +134,12 @@ ProcXIPassiveGrabDevice(ClientPtr client)
         return BadValue;
     }
 
+    /* XI2 allows 32-bit keycodes but thanks to XKB we can never
+     * implement this. Just return an error for all keycodes that
+     * cannot work anyway, same for buttons > 255. */
+    if (stuff->detail > 255)
+        return XIAlreadyGrabbed;
+
     if (XICheckInvalidMaskBits(client, (unsigned char *) &stuff[1],
                                stuff->mask_len * 4) != Success)
         return BadValue;
@@ -228,9 +235,11 @@ ProcXIPassiveGrabDevice(ClientPtr client)
         }
     }
 
+    /* save the value before SRepXIPassiveGrabDevice swaps it */
+    length = rep.length;
     WriteReplyToClient(client, sizeof(rep), &rep);
     if (rep.num_modifiers)
-        WriteToClient(client, rep.length * 4, modifiers_failed);
+        WriteToClient(client, length * 4, modifiers_failed);
 
     free(modifiers_failed);
  out:
@@ -313,6 +322,12 @@ ProcXIPassiveUngrabDevice(ClientPtr client)
         return BadValue;
     }
 
+    /* We don't allow passive grabs for details > 255 anyway */
+    if (stuff->detail > 255) {
+        client->errorValue = stuff->detail;
+        return BadValue;
+    }
+
     rc = dixLookupWindow(&win, stuff->grab_window, client, DixSetAttrAccess);
     if (rc != Success)
         return rc;
diff --git a/xorg-server-1.19.7/Xi/xiproperty.c b/Xserver/Xi/xiproperty.c
index b7a1f59..f499d02 100644
--- a/xorg-server-1.19.7/Xi/xiproperty.c
+++ b/Xserver/Xi/xiproperty.c
@@ -732,7 +732,7 @@ XIChangeDeviceProperty(DeviceIntPtr dev, Atom property, Atom type,
                 XIDestroyDeviceProperty(prop);
             return BadAlloc;
         }
-        new_value.size = len;
+        new_value.size = total_len;
         new_value.type = type;
         new_value.format = format;
 
@@ -749,7 +749,7 @@ XIChangeDeviceProperty(DeviceIntPtr dev, Atom property, Atom type,
         case PropModePrepend:
             new_data = new_value.data;
             old_data = (void *) (((char *) new_value.data) +
-                                  (prop_value->size * size_in_bytes));
+                                  (len * size_in_bytes));
             break;
         }
         if (new_data)
@@ -892,7 +892,7 @@ ProcXChangeDeviceProperty(ClientPtr client)
     REQUEST(xChangeDevicePropertyReq);
     DeviceIntPtr dev;
     unsigned long len;
-    int totalSize;
+    uint64_t totalSize;
     int rc;
 
     REQUEST_AT_LEAST_SIZE(xChangeDevicePropertyReq);
@@ -1130,7 +1130,7 @@ ProcXIChangeProperty(ClientPtr client)
 {
     int rc;
     DeviceIntPtr dev;
-    int totalSize;
+    uint64_t totalSize;
     unsigned long len;
 
     REQUEST(xXIChangePropertyReq);
diff --git a/xorg-server-1.19.7/Xi/xiquerypointer.c b/Xserver/Xi/xiquerypointer.c
index c5b0ba7..e82c44f 100644
--- a/xorg-server-1.19.7/Xi/xiquerypointer.c
+++ b/Xserver/Xi/xiquerypointer.c
@@ -149,8 +149,7 @@ ProcXIQueryPointer(ClientPtr client)
     if (pDev->button) {
         int i;
 
-        rep.buttons_len =
-            bytes_to_int32(bits_to_bytes(pDev->button->numButtons));
+        rep.buttons_len = bytes_to_int32(bits_to_bytes(256)); /* button map up to 255 */
         rep.length += rep.buttons_len;
         buttons = calloc(rep.buttons_len, 4);
         if (!buttons)
diff --git a/xorg-server-1.19.7/Xi/xiselectev.c b/Xserver/Xi/xiselectev.c
index 168579f..3352ee4 100644
--- a/xorg-server-1.19.7/Xi/xiselectev.c
+++ b/Xserver/Xi/xiselectev.c
@@ -297,6 +297,7 @@ ProcXIGetSelectedEvents(ClientPtr client)
     InputClientsPtr others = NULL;
     xXIEventMask *evmask = NULL;
     DeviceIntPtr dev;
+    uint32_t length;
 
     REQUEST(xXIGetSelectedEventsReq);
     REQUEST_SIZE_MATCH(xXIGetSelectedEventsReq);
@@ -366,10 +367,12 @@ ProcXIGetSelectedEvents(ClientPtr client)
         }
     }
 
+    /* save the value before SRepXIGetSelectedEvents swaps it */
+    length = reply.length;
     WriteReplyToClient(client, sizeof(xXIGetSelectedEventsReply), &reply);
 
     if (reply.num_masks)
-        WriteToClient(client, reply.length * 4, buffer);
+        WriteToClient(client, length * 4, buffer);
 
     free(buffer);
     return Success;
diff --git a/xorg-server-1.19.7/composite/compwindow.c b/Xserver/composite/compwindow.c
index e74ce66..db940ec 100644
--- a/xorg-server-1.19.7/composite/compwindow.c
+++ b/Xserver/composite/compwindow.c
@@ -612,6 +612,11 @@ compDestroyWindow(WindowPtr pWin)
     ret = (*pScreen->DestroyWindow) (pWin);
     cs->DestroyWindow = pScreen->DestroyWindow;
     pScreen->DestroyWindow = compDestroyWindow;
+
+    /* Did we just destroy the overlay window? */
+    if (pWin == cs->pOverlayWin)
+        cs->pOverlayWin = NULL;
+
 /*    compCheckTree (pWin->drawable.pScreen); can't check -- tree isn't good*/
     return ret;
 }
diff --git a/xorg-server-1.19.7/dix/devices.c b/Xserver/dix/devices.c
index 4a628af..1109475 100644
--- a/xorg-server-1.19.7/dix/devices.c
+++ b/Xserver/dix/devices.c
@@ -76,6 +76,11 @@ SOFTWARE.
 #include <X11/extensions/XI2.h>
 #include <X11/extensions/XIproto.h>
 #include <math.h>
+#ifdef TURBOVNC
+#ifdef HAVE_IEEEFP_H
+#include <ieeefp.h>
+#endif
+#endif
 #include <pixman.h>
 #include "exglobals.h"
 #include "exevents.h"
@@ -174,7 +179,11 @@ DeviceSetProperty(DeviceIntPtr dev, Atom property, XIPropertyValuePtr prop,
             return BadValue;
 
         for (i = 0; i < 9; i++)
+#ifdef TURBOVNC
+            if (!finite(f[i]))
+#else
             if (!isfinite(f[i]))
+#endif
                 return BadValue;
 
         if (!dev->valuator)
@@ -451,14 +460,20 @@ DisableDevice(DeviceIntPtr dev, BOOL sendevent)
 {
     DeviceIntPtr *prev, other;
     BOOL enabled;
+    BOOL dev_in_devices_list = FALSE;
     int flags[MAXDEVICES] = { 0 };
 
     if (!dev->enabled)
         return TRUE;
 
-    for (prev = &inputInfo.devices;
-         *prev && (*prev != dev); prev = &(*prev)->next);
-    if (*prev != dev)
+    for (other = inputInfo.devices; other; other = other->next) {
+        if (other == dev) {
+            dev_in_devices_list = TRUE;
+            break;
+        }
+    }
+
+    if (!dev_in_devices_list)
         return FALSE;
 
     TouchEndPhysicallyActiveTouches(dev);
@@ -474,6 +489,13 @@ DisableDevice(DeviceIntPtr dev, BOOL sendevent)
                 flags[other->id] |= XISlaveDetached;
             }
         }
+
+        for (other = inputInfo.off_devices; other; other = other->next) {
+            if (!IsMaster(other) && GetMaster(other, MASTER_ATTACHED) == dev) {
+                AttachDevice(NULL, other, NULL);
+                flags[other->id] |= XISlaveDetached;
+            }
+        }
     }
     else {
         for (other = inputInfo.devices; other; other = other->next) {
@@ -508,6 +530,9 @@ DisableDevice(DeviceIntPtr dev, BOOL sendevent)
     LeaveWindow(dev);
     SetFocusOut(dev);
 
+    for (prev = &inputInfo.devices;
+         *prev && (*prev != dev); prev = &(*prev)->next);
+
     *prev = dev->next;
     dev->next = inputInfo.off_devices;
     inputInfo.off_devices = dev;
@@ -1067,6 +1092,11 @@ CloseDownDevices(void)
             dev->master = NULL;
     }
 
+    for (dev = inputInfo.off_devices; dev; dev = dev->next) {
+        if (!IsMaster(dev) && !IsFloating(dev))
+            dev->master = NULL;
+    }
+
     CloseDeviceList(&inputInfo.devices);
     CloseDeviceList(&inputInfo.off_devices);
 
@@ -2497,6 +2527,8 @@ RecalculateMasterButtons(DeviceIntPtr slave)
 
     if (master->button && master->button->numButtons != maxbuttons) {
         int i;
+        int last_num_buttons = master->button->numButtons;
+
         DeviceChangedEvent event = {
             .header = ET_Internal,
             .type = ET_DeviceChanged,
@@ -2507,6 +2539,14 @@ RecalculateMasterButtons(DeviceIntPtr slave)
         };
 
         master->button->numButtons = maxbuttons;
+        if (last_num_buttons < maxbuttons) {
+            master->button->xkb_acts = xnfreallocarray(master->button->xkb_acts,
+                                                       maxbuttons,
+                                                       sizeof(XkbAction));
+            memset(&master->button->xkb_acts[last_num_buttons],
+                   0,
+                   (maxbuttons - last_num_buttons) * sizeof(XkbAction));
+        }
 
         memcpy(&event.buttons.names, master->button->labels, maxbuttons *
                sizeof(Atom));
diff --git a/xorg-server-1.19.7/dix/enterleave.c b/Xserver/dix/enterleave.c
index 1b341f2..99381a2 100644
--- a/xorg-server-1.19.7/dix/enterleave.c
+++ b/Xserver/dix/enterleave.c
@@ -615,9 +615,15 @@ FixDeviceValuator(DeviceIntPtr dev, deviceValuator * ev, ValuatorClassPtr v,
 
     ev->type = DeviceValuator;
     ev->deviceid = dev->id;
-    ev->num_valuators = nval < 3 ? nval : 3;
+    ev->num_valuators = nval < 6 ? nval : 6;
     ev->first_valuator = first;
     switch (ev->num_valuators) {
+    case 6:
+        ev->valuator2 = v->axisVal[first + 5];
+    case 5:
+        ev->valuator2 = v->axisVal[first + 4];
+    case 4:
+        ev->valuator2 = v->axisVal[first + 3];
     case 3:
         ev->valuator2 = v->axisVal[first + 2];
     case 2:
@@ -626,7 +632,6 @@ FixDeviceValuator(DeviceIntPtr dev, deviceValuator * ev, ValuatorClassPtr v,
         ev->valuator0 = v->axisVal[first];
         break;
     }
-    first += ev->num_valuators;
 }
 
 static void
@@ -646,7 +651,7 @@ FixDeviceStateNotify(DeviceIntPtr dev, deviceStateNotify * ev, KeyClassPtr k,
         ev->num_buttons = b->numButtons;
         memcpy((char *) ev->buttons, (char *) b->down, 4);
     }
-    else if (k) {
+    if (k) {
         ev->classes_reported |= (1 << KeyClass);
         ev->num_keys = k->xkbInfo->desc->max_key_code -
             k->xkbInfo->desc->min_key_code;
@@ -670,14 +675,26 @@ FixDeviceStateNotify(DeviceIntPtr dev, deviceStateNotify * ev, KeyClassPtr k,
     }
 }
 
-
+/**
+ * The device state notify event is split across multiple 32-byte events.
+ * The first one contains the first 32 button state bits, the first 32
+ * key state bits, and the first 3 valuator values.
+ *
+ * If a device has more than that, the server sends out:
+ * - one deviceButtonStateNotify for buttons 32 and above
+ * - one deviceKeyStateNotify for keys 32 and above
+ * - one deviceValuator event per 6 valuators above valuator 4
+ *
+ * All events but the last one have the deviceid binary ORed with MORE_EVENTS,
+ */
 static void
 DeliverStateNotifyEvent(DeviceIntPtr dev, WindowPtr win)
 {
+    /* deviceStateNotify, deviceKeyStateNotify, deviceButtonStateNotify
+     * and one deviceValuator for each 6 valuators */
+    deviceStateNotify sev[3 + (MAX_VALUATORS + 6)/6];
     int evcount = 1;
-    deviceStateNotify *ev, *sev;
-    deviceKeyStateNotify *kev;
-    deviceButtonStateNotify *bev;
+    deviceStateNotify *ev = sev;
 
     KeyClassPtr k;
     ButtonClassPtr b;
@@ -690,87 +707,53 @@ DeliverStateNotifyEvent(DeviceIntPtr dev, WindowPtr win)
 
     if ((b = dev->button) != NULL) {
         nbuttons = b->numButtons;
-        if (nbuttons > 32)
+        if (nbuttons > 32) /* first 32 are encoded in deviceStateNotify */
             evcount++;
     }
     if ((k = dev->key) != NULL) {
         nkeys = k->xkbInfo->desc->max_key_code - k->xkbInfo->desc->min_key_code;
-        if (nkeys > 32)
+        if (nkeys > 32) /* first 32 are encoded in deviceStateNotify */
             evcount++;
-        if (nbuttons > 0) {
-            evcount++;
-        }
     }
     if ((v = dev->valuator) != NULL) {
         nval = v->numAxes;
-
-        if (nval > 3)
-            evcount++;
-        if (nval > 6) {
-            if (!(k && b))
-                evcount++;
-            if (nval > 9)
-                evcount += ((nval - 7) / 3);
-        }
+        /* first three are encoded in deviceStateNotify, then
+         * it's 6 per deviceValuator event */
+        evcount += ((nval - 3) + 6)/6;
     }
 
-    sev = ev = xallocarray(evcount, sizeof(xEvent));
-    FixDeviceStateNotify(dev, ev, NULL, NULL, NULL, first);
-
-    if (b != NULL) {
-        FixDeviceStateNotify(dev, ev++, NULL, b, v, first);
-        first += 3;
-        nval -= 3;
-        if (nbuttons > 32) {
-            (ev - 1)->deviceid |= MORE_EVENTS;
-            bev = (deviceButtonStateNotify *) ev++;
-            bev->type = DeviceButtonStateNotify;
-            bev->deviceid = dev->id;
-            memcpy((char *) &bev->buttons[4], (char *) &b->down[4],
-                   DOWN_LENGTH - 4);
-        }
-        if (nval > 0) {
-            (ev - 1)->deviceid |= MORE_EVENTS;
-            FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
-            first += 3;
-            nval -= 3;
-        }
+    BUG_RETURN(evcount <= ARRAY_SIZE(sev));
+
+    FixDeviceStateNotify(dev, ev, k, b, v, first);
+
+    if (b != NULL && nbuttons > 32) {
+        deviceButtonStateNotify *bev = (deviceButtonStateNotify *) ++ev;
+        (ev - 1)->deviceid |= MORE_EVENTS;
+        bev->type = DeviceButtonStateNotify;
+        bev->deviceid = dev->id;
+        memcpy((char *) &bev->buttons[4], (char *) &b->down[4],
+               DOWN_LENGTH - 4);
     }
 
-    if (k != NULL) {
-        FixDeviceStateNotify(dev, ev++, k, NULL, v, first);
-        first += 3;
-        nval -= 3;
-        if (nkeys > 32) {
-            (ev - 1)->deviceid |= MORE_EVENTS;
-            kev = (deviceKeyStateNotify *) ev++;
-            kev->type = DeviceKeyStateNotify;
-            kev->deviceid = dev->id;
-            memmove((char *) &kev->keys[0], (char *) &k->down[4], 28);
-        }
-        if (nval > 0) {
-            (ev - 1)->deviceid |= MORE_EVENTS;
-            FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
-            first += 3;
-            nval -= 3;
-        }
+    if (k != NULL && nkeys > 32) {
+        deviceKeyStateNotify *kev = (deviceKeyStateNotify *) ++ev;
+        (ev - 1)->deviceid |= MORE_EVENTS;
+        kev->type = DeviceKeyStateNotify;
+        kev->deviceid = dev->id;
+        memmove((char *) &kev->keys[0], (char *) &k->down[4], 28);
     }
 
+    first = 3;
+    nval -= 3;
     while (nval > 0) {
-        FixDeviceStateNotify(dev, ev++, NULL, NULL, v, first);
-        first += 3;
-        nval -= 3;
-        if (nval > 0) {
-            (ev - 1)->deviceid |= MORE_EVENTS;
-            FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
-            first += 3;
-            nval -= 3;
-        }
+        ev->deviceid |= MORE_EVENTS;
+        FixDeviceValuator(dev, (deviceValuator *) ++ev, v, first);
+        first += 6;
+        nval -= 6;
     }
 
     DeliverEventsToWindow(dev, win, (xEvent *) sev, evcount,
                           DeviceStateNotifyMask, NullGrab);
-    free(sev);
 }
 
 void
@@ -784,8 +767,9 @@ DeviceFocusEvent(DeviceIntPtr dev, int type, int mode, int detail,
 
     mouse = IsFloating(dev) ? dev : GetMaster(dev, MASTER_POINTER);
 
-    /* XI 2 event */
-    btlen = (mouse->button) ? bits_to_bytes(mouse->button->numButtons) : 0;
+    /* XI 2 event contains the logical button map - maps are CARD8
+     * so we need 256 bits for the possibly maximum mapping */
+    btlen = (mouse->button) ? bits_to_bytes(256) : 0;
     btlen = bytes_to_int32(btlen);
     len = sizeof(xXIFocusInEvent) + btlen * 4;
 
diff --git a/xorg-server-1.19.7/dix/events.c b/Xserver/dix/events.c
index 3faad53..45a91d8 100644
--- a/xorg-server-1.19.7/dix/events.c
+++ b/Xserver/dix/events.c
@@ -148,6 +148,12 @@ Equipment Corporation.
 #include "eventconvert.h"
 #include "mi.h"
 
+#ifdef TURBOVNC
+extern Window vncGetSelectionWindow(void);
+extern void vncHandleSelection(Atom selection, Atom target, Atom property,
+                               Atom requestor, TimeStamp time);
+#endif
+
 /* Extension events type numbering starts at EXTENSION_EVENT_BASE.  */
 #define NoSuchEvent 0x80000000  /* so doesn't match NoEventMask */
 #define StructureAndSubMask ( StructureNotifyMask | SubstructureNotifyMask )
@@ -5356,6 +5362,18 @@ ProcSendEvent(ClientPtr client)
 
     stuff->event.u.u.type &= ~(SEND_EVENT_BIT);
 
+#ifdef TURBOVNC
+    if (stuff->event.u.u.type == SelectionNotify &&
+        stuff->event.u.selectionNotify.requestor == vncGetSelectionWindow()) {
+        TimeStamp time;
+        time = ClientTimeToServerTime(stuff->event.u.selectionNotify.time);
+        vncHandleSelection(stuff->event.u.selectionNotify.selection,
+                           stuff->event.u.selectionNotify.target,
+                           stuff->event.u.selectionNotify.property,
+                           stuff->event.u.selectionNotify.requestor, time);
+    }
+#endif
+
     /* The client's event type must be a core event type or one defined by an
        extension. */
 
diff --git a/xorg-server-1.19.7/dix/property.c b/Xserver/dix/property.c
index fa4da2d..dd6b187 100644
--- a/xorg-server-1.19.7/dix/property.c
+++ b/Xserver/dix/property.c
@@ -196,7 +196,8 @@ ProcChangeProperty(ClientPtr client)
     WindowPtr pWin;
     char format, mode;
     unsigned long len;
-    int sizeInBytes, totalSize, err;
+    int sizeInBytes, err;
+    uint64_t totalSize;
 
     REQUEST(xChangePropertyReq);
 
@@ -353,6 +354,13 @@ dixChangeWindowProperty(ClientPtr pClient, WindowPtr pWin, Atom property,
     if (sendevent)
         deliverPropertyNotifyEvent(pWin, PropertyNewValue, pProp->propertyName);
 
+#ifdef TURBOVNC
+    if (pWin->parent == NullWindow) {
+        extern void rfbRootPropertyChange();
+        rfbRootPropertyChange(pProp);
+    }
+#endif
+
     return Success;
 }
 
diff --git a/xorg-server-1.19.7/dix/registry.c b/Xserver/dix/registry.c
index 84d48b4..de4bf8e 100644
--- a/xorg-server-1.19.7/dix/registry.c
+++ b/Xserver/dix/registry.c
@@ -1,6 +1,7 @@
 /************************************************************
 
-Author: Eamon Walsh <ewalsh@tycho.nsa.gov>
+Authors: Eamon Walsh <ewalsh@tycho.nsa.gov>
+         D. R. Commander
 
 Permission to use, copy, modify, distribute, and sell this software and its
 documentation for any purpose is hereby granted without fee, provided that
@@ -32,7 +33,12 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #ifdef X_REGISTRY_REQUEST
 #define CORE "X11"
+#ifdef TURBOVNC
+char registry_path[PATH_MAX] = SERVER_MISC_CONFIG_PATH "/protocol.txt";
+#define FILENAME registry_path
+#else
 #define FILENAME SERVER_MISC_CONFIG_PATH "/protocol.txt"
+#endif
 
 #define PROT_COMMENT '#'
 #define PROT_REQUEST 'R'
@@ -202,7 +208,11 @@ RegisterExtensionNames(ExtensionEntry * extEntry)
         }
 
  invalid:
+#ifdef TURBOVNC
+        LogMessage(X_WARNING, "Invalid line in %s, skipping\n", FILENAME);
+#else
         LogMessage(X_WARNING, "Invalid line in " FILENAME ", skipping\n");
+#endif
  skip:
         free(lineobj);
     }
@@ -353,7 +363,11 @@ dixResetRegistry(void)
     fh = fopen(FILENAME, "r");
     if (!fh)
         LogMessage(X_WARNING,
+#ifdef TURBOVNC
+                   "Failed to open protocol names file %s\n", FILENAME);
+#else
                    "Failed to open protocol names file " FILENAME "\n");
+#endif
 
     /* Add the core protocol */
     RegisterExtensionNames(&extEntry);
diff --git a/xorg-server-1.19.7/dix/selection.c b/Xserver/dix/selection.c
index d46103f..af0e36e 100644
--- a/xorg-server-1.19.7/dix/selection.c
+++ b/Xserver/dix/selection.c
@@ -54,6 +54,12 @@ SOFTWARE.
 #include "selection.h"
 #include "xace.h"
 
+#ifdef TURBOVNC
+extern int vncConvertSelection(ClientPtr client, Atom selection, Atom target,
+                               Atom property, Window requestor, CARD32 time);
+extern Window vncGetSelectionWindow(void);
+#endif
+
 /*****************************************************************
  * Selection Stuff
  *
@@ -287,6 +293,15 @@ ProcConvertSelection(ClientPtr client)
     memset(&event, 0, sizeof(xEvent));
     if (rc != Success && rc != BadMatch)
         return rc;
+#ifdef TURBOVNC
+    else if (rc == Success && pSel->client == serverClient &&
+             pSel->window == vncGetSelectionWindow()) {
+        rc = vncConvertSelection(client, stuff->selection, stuff->target,
+                                 stuff->property, stuff->requestor,
+                                 stuff->time);
+        if (rc == Success) return rc;
+    }
+#endif
     else if (rc == Success && pSel->window != None) {
         event.u.u.type = SelectionRequest;
         event.u.selectionRequest.owner = pSel->window;
diff --git a/xorg-server-1.19.7/glx/glxcmds.c b/Xserver/glx/glxcmds.c
index 295857b..0b5e4c9 100644
--- a/xorg-server-1.19.7/glx/glxcmds.c
+++ b/Xserver/glx/glxcmds.c
@@ -46,6 +46,7 @@
 #include "indirect_table.h"
 #include "indirect_util.h"
 #include "protocol-versions.h"
+#include "xace.h"
 
 static char GLXServerVendorName[] = "SGI";
 
@@ -1455,6 +1456,13 @@ DoCreatePbuffer(ClientPtr client, int screenNum, XID fbconfigId,
     if (!pPixmap)
         return BadAlloc;
 
+    err = XaceHook(XACE_RESOURCE_ACCESS, client, glxDrawableId, RT_PIXMAP,
+                   pPixmap, RT_NONE, NULL, DixCreateAccess);
+    if (err != Success) {
+        (*pGlxScreen->pScreen->DestroyPixmap) (pPixmap);
+        return err;
+    }
+
     /* Assign the pixmap the same id as the pbuffer and add it as a
      * resource so it and the DRI2 drawable will be reclaimed when the
      * pbuffer is destroyed. */
diff --git a/xorg-server-1.19.7/glx/glxdricommon.c b/Xserver/glx/glxdricommon.c
index dbf199c..c7430c2 100644
--- a/xorg-server-1.19.7/glx/glxdricommon.c
+++ b/Xserver/glx/glxdricommon.c
@@ -41,29 +41,6 @@
 #include "glxscreens.h"
 #include "glxdricommon.h"
 
-static int
-getUST(int64_t * ust)
-{
-    struct timeval tv;
-
-    if (ust == NULL)
-        return -EFAULT;
-
-    if (gettimeofday(&tv, NULL) == 0) {
-        ust[0] = (tv.tv_sec * 1000000) + tv.tv_usec;
-        return 0;
-    }
-    else {
-        return -errno;
-    }
-}
-
-const __DRIsystemTimeExtension systemTimeExtension = {
-    {__DRI_SYSTEM_TIME, 1},
-    getUST,
-    NULL,
-};
-
 #define __ATTRIB(attrib, field) \
     { attrib, offsetof(__GLXconfig, field) }
 
@@ -275,7 +252,11 @@ glxConvertConfigs(const __DRIcoreExtension * core,
     return head.next;
 }
 
+#ifdef TURBOVNC
+char *dri_driver_path = DRI_DRIVER_PATH;
+#else
 static const char dri_driver_path[] = DRI_DRIVER_PATH;
+#endif
 
 /* Temporary define to allow building without a dri_interface.h from
  * updated Mesa.  Some day when we don't care about Mesa that old any
diff --git a/xorg-server-1.19.7/glx/glxdricommon.h b/Xserver/glx/glxdricommon.h
index 2db46dc..6851f24 100644
--- a/xorg-server-1.19.7/glx/glxdricommon.h
+++ b/Xserver/glx/glxdricommon.h
@@ -35,8 +35,6 @@ struct __GLXDRIconfig {
 __GLXconfig *glxConvertConfigs(const __DRIcoreExtension * core,
                                const __DRIconfig ** configs);
 
-extern const __DRIsystemTimeExtension systemTimeExtension;
-
 void *glxProbeDriver(const char *name,
                      void **coreExt, const char *coreName, int coreVersion,
                      void **renderExt, const char *renderName,
diff --git a/xorg-server-1.19.7/glx/glxdriswrast.c b/Xserver/glx/glxdriswrast.c
index e310fda..b0b24ae 100644
--- a/xorg-server-1.19.7/glx/glxdriswrast.c
+++ b/Xserver/glx/glxdriswrast.c
@@ -367,7 +367,6 @@ static const __DRIswrastLoaderExtension swrastLoaderExtension = {
 };
 
 static const __DRIextension *loader_extensions[] = {
-    &systemTimeExtension.base,
     &swrastLoaderExtension.base,
     NULL
 };
diff --git a/xorg-server-1.19.7/glx/glxext.c b/Xserver/glx/glxext.c
index d595a05..b81adad 100644
--- a/xorg-server-1.19.7/glx/glxext.c
+++ b/Xserver/glx/glxext.c
@@ -1,6 +1,7 @@
 /*
  * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
  * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ * Copyright (C) 2017 D. R. Commander. All Rights Reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -47,6 +48,10 @@
 #include "indirect_table.h"
 #include "indirect_util.h"
 
+#ifdef TURBOVNC
+Bool indirectGlxActive = FALSE;
+#endif
+
 /*
 ** X resources.
 */
@@ -166,6 +171,12 @@ __glXAddContext(__GLXcontext * cx)
 
     cx->next = glxAllContexts;
     glxAllContexts = cx;
+#ifdef TURBOVNC
+    if (!indirectGlxActive && !cx->isDirect) {
+        LogMessage(X_INFO, "Activating indirect GLX ...\n");
+        indirectGlxActive = TRUE;
+    }
+#endif
     return True;
 }
 
@@ -173,6 +184,9 @@ static void
 __glXRemoveFromContextList(__GLXcontext * cx)
 {
     __GLXcontext *c, *prev;
+#ifdef TURBOVNC
+    Bool indirectGlxStillActive = FALSE;
+#endif
 
     if (cx == glxAllContexts)
         glxAllContexts = cx->next;
@@ -184,6 +198,18 @@ __glXRemoveFromContextList(__GLXcontext * cx)
             prev = c;
         }
     }
+#ifdef TURBOVNC
+    for (c = glxAllContexts; c; c = c->next) {
+        if (!c->isDirect) {
+            indirectGlxStillActive = TRUE;
+            break;
+        }
+    }
+    if (indirectGlxActive && !indirectGlxStillActive) {
+        LogMessage(X_INFO, "Deactivating indirect GLX ...\n");
+        indirectGlxActive = FALSE;
+    }
+#endif
 }
 
 /*
diff --git a/xorg-server-1.19.7/glx/glxscreens.c b/Xserver/glx/glxscreens.c
index 62d66bc..abedb82 100644
--- a/xorg-server-1.19.7/glx/glxscreens.c
+++ b/Xserver/glx/glxscreens.c
@@ -285,7 +285,8 @@ pickFBConfig(__GLXscreen * pGlxScreen, VisualPtr visual)
             continue;
 #ifdef COMPOSITE
 	/* Use only duplicated configs for compIsAlternateVisuals */
-        if (!!compIsAlternateVisual(pGlxScreen->pScreen, visual->vid) !=
+        if (!noCompositeExtension &&
+	    !!compIsAlternateVisual(pGlxScreen->pScreen, visual->vid) !=
 	    !!config->duplicatedForComp)
             continue;
 #endif
@@ -357,7 +358,8 @@ __glXScreenInit(__GLXscreen * pGlxScreen, ScreenPtr pScreen)
             pGlxScreen->visuals[pGlxScreen->numVisuals++] = config;
             config->visualID = visual->vid;
 #ifdef COMPOSITE
-            if (compIsAlternateVisual(pScreen, visual->vid))
+            if (!noCompositeExtension &&
+                compIsAlternateVisual(pScreen, visual->vid))
                 config->visualSelectGroup++;
 #endif
         }
diff --git a/xorg-server-1.19.7/include/extinit.h b/Xserver/include/extinit.h
index 4ad4fca..08fa370 100644
--- a/xorg-server-1.19.7/include/extinit.h
+++ b/Xserver/include/extinit.h
@@ -1,6 +1,7 @@
 /************************************************************
 
 Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+Copyright 2017 D. R. Commander
 
                         All Rights Reserved
 
@@ -181,4 +182,13 @@ extern void dri3_extension_init(void);
 #include "presentext.h"
 #endif
 
+#ifdef TURBOVNC
+extern void vncExtensionInit(void);
+
+#ifdef NVCONTROL
+extern Bool noNVCTRLExtension;
+extern void nvCtrlExtensionInit(void);
+#endif
+#endif
+
 #endif
diff --git a/xorg-server-1.19.7/mi/miinitext.c b/Xserver/mi/miinitext.c
index 5fc44e3..628e9f3 100644
--- a/xorg-server-1.19.7/mi/miinitext.c
+++ b/Xserver/mi/miinitext.c
@@ -1,6 +1,7 @@
 /***********************************************************
 
 Copyright 1987, 1998  The Open Group
+Copyright 2012, 2015, 2017  D. R. Commander
 
 Permission to use, copy, modify, distribute, and sell this software and its
 documentation for any purpose is hereby granted without fee, provided that
@@ -306,6 +307,12 @@ static const ExtensionModule staticExtensions[] = {
 #ifdef XSELINUX
     {SELinuxExtensionInit, SELINUX_EXTENSION_NAME, &noSELinuxExtension},
 #endif
+#ifdef TURBOVNC
+    {vncExtensionInit, "VNC-EXTENSION", NULL},
+#ifdef NVCONTROL
+    {nvCtrlExtensionInit, "NV-CONTROL", &noNVCTRLExtension},
+#endif
+#endif
 };
 
 static ExtensionModule *ExtensionModuleList = NULL;
diff --git a/xorg-server-1.19.7/os/WaitFor.c b/Xserver/os/WaitFor.c
index 613608f..66c5c69 100644
--- a/xorg-server-1.19.7/os/WaitFor.c
+++ b/Xserver/os/WaitFor.c
@@ -1,6 +1,7 @@
 /***********************************************************
 
 Copyright 1987, 1998  The Open Group
+Copyright 2017  D. R. Commander
 
 Permission to use, copy, modify, distribute, and sell this software and its
 documentation for any purpose is hereby granted without fee, provided that
@@ -188,6 +189,11 @@ WaitForSomething(Bool are_ready)
     int pollerr;
     static Bool were_ready;
     Bool timer_is_running;
+#if defined(TURBOVNC) && defined(GLXEXT)
+    CARD32 now = 0;
+    OsTimerPtr timer;
+    extern Bool indirectGlxActive;
+#endif
 
     timer_is_running = were_ready;
 
@@ -238,6 +244,26 @@ WaitForSomething(Bool are_ready)
         } else
             are_ready = clients_are_ready();
 
+#if defined(TURBOVNC) && defined(GLXEXT)
+        if (indirectGlxActive) {
+            /* This basically restores the logic from xorg-server 1.18.x and
+               earlier.  Without it, the timers in the VNC server are never
+               invoked (and thus framebuffer updates are never sent) while
+               indirect OpenGL applications are running. */
+            if (i > 0) {
+                if (InputCheckPending())
+                    return FALSE;
+
+                if ((timer = first_timer()) != NULL) {
+                    now = GetTimeInMillis();
+                    if ((int) (timer->expires - now) <= 0) {
+                        DoTimers(now);
+                        return FALSE;
+                    }
+                }
+            }
+        } else
+#endif
         if (InputCheckPending())
             return FALSE;
 
diff --git a/xorg-server-1.19.7/os/backtrace.c b/Xserver/os/backtrace.c
index 9e3e38e..b9d2c0f 100644
--- a/xorg-server-1.19.7/os/backtrace.c
+++ b/Xserver/os/backtrace.c
@@ -156,8 +156,10 @@ xorg_backtrace(void)
 #else                           /* not glibc or glibc < 2.1 */
 
 #if defined(__sun) && defined(__SVR4)
+#ifndef TURBOVNC
 #define HAVE_PSTACK
 #endif
+#endif
 
 #if defined(HAVE_WALKCONTEXT)   /* Solaris 9 & later */
 
diff --git a/xorg-server-1.19.7/os/log.c b/Xserver/os/log.c
index 91e55a5..1705b0e 100644
--- a/xorg-server-1.19.7/os/log.c
+++ b/Xserver/os/log.c
@@ -645,7 +645,7 @@ LogSWrite(int verb, const char *buf, size_t len, Bool end_line)
 void
 LogVWrite(int verb, const char *f, va_list args)
 {
-    return LogVMessageVerb(X_NONE, verb, f, args);
+    LogVMessageVerb(X_NONE, verb, f, args);
 }
 
 void
diff --git a/xorg-server-1.19.7/os/utils.c b/Xserver/os/utils.c
index 6dcf328..f0cdffa 100644
--- a/xorg-server-1.19.7/os/utils.c
+++ b/Xserver/os/utils.c
@@ -1,6 +1,7 @@
 /*
 
 Copyright 1987, 1998  The Open Group
+Copyright 2017  D. R. Commander
 
 Permission to use, copy, modify, distribute, and sell this software and its
 documentation for any purpose is hereby granted without fee, provided that
@@ -194,7 +195,11 @@ Bool noGEExtension = FALSE;
 
 Bool CoreDump;
 
+#ifdef TURBOVNC
+Bool enableIndirectGLX = TRUE;
+#else
 Bool enableIndirectGLX = FALSE;
+#endif
 
 #ifdef PANORAMIX
 Bool PanoramiXExtensionDisabledHack = FALSE;
@@ -540,8 +545,13 @@ UseMsg(void)
     ErrorF("-fn string             default font name\n");
     ErrorF("-fp string             default font path\n");
     ErrorF("-help                  prints message with these options\n");
+#ifdef TURBOVNC
+    ErrorF("+iglx                  Allow creating indirect GLX contexts (default)\n");
+    ErrorF("-iglx                  Prohibit creating indirect GLX contexts\n");
+#else
     ErrorF("+iglx                  Allow creating indirect GLX contexts\n");
     ErrorF("-iglx                  Prohibit creating indirect GLX contexts (default)\n");
+#endif
     ErrorF("-I                     ignore all remaining arguments\n");
 #ifdef RLIMIT_DATA
     ErrorF("-ld int                limit data space to N Kb\n");
@@ -1257,7 +1267,9 @@ SmartScheduleEnable(void)
     memset((char *) &act, 0, sizeof(struct sigaction));
 
     /* Set up the timer signal function */
+#ifdef SA_RESTART
     act.sa_flags = SA_RESTART;
+#endif
     act.sa_handler = SmartScheduleTimer;
     sigemptyset(&act.sa_mask);
     sigaddset(&act.sa_mask, SIGALRM);
diff --git a/xorg-server-1.19.7/randr/rrmode.c b/Xserver/randr/rrmode.c
index a7aa433..149adb1 100644
--- a/xorg-server-1.19.7/randr/rrmode.c
+++ b/Xserver/randr/rrmode.c
@@ -1,5 +1,6 @@
 /*
  * Copyright © 2006 Keith Packard
+ * Copyright © 2017 D. R. Commander
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -68,6 +69,15 @@ RRModeCreate(xRRModeInfo * modeInfo, const char *name, ScreenPtr userScreen)
     if (!RRInit())
         return NULL;
 
+#ifdef TURBOVNC
+    /*
+     * The screen structure uses a signed short to represent width and height,
+     * so activating a mode with width or height > 32767 can crash the server.
+     */
+    if (modeInfo->width > MAXSHORT || modeInfo->height > MAXSHORT)
+        return NULL;
+#endif
+
     mode = malloc(sizeof(RRModeRec) + modeInfo->nameLength + 1);
     if (!mode)
         return NULL;
diff --git a/xorg-server-1.19.7/randr/rrproperty.c b/Xserver/randr/rrproperty.c
index e56626c..1a2deaf 100644
--- a/xorg-server-1.19.7/randr/rrproperty.c
+++ b/Xserver/randr/rrproperty.c
@@ -185,7 +185,7 @@ RRChangeOutputProperty(RROutputPtr output, Atom property, Atom type,
                 RRDestroyOutputProperty(prop);
             return BadAlloc;
         }
-        new_value.size = len;
+        new_value.size = total_len;
         new_value.type = type;
         new_value.format = format;
 
@@ -202,7 +202,7 @@ RRChangeOutputProperty(RROutputPtr output, Atom property, Atom type,
         case PropModePrepend:
             new_data = new_value.data;
             old_data = (void *) (((char *) new_value.data) +
-                                  (prop_value->size * size_in_bytes));
+                                  (len * size_in_bytes));
             break;
         }
         if (new_data)
@@ -500,7 +500,7 @@ ProcRRChangeOutputProperty(ClientPtr client)
     char format, mode;
     unsigned long len;
     int sizeInBytes;
-    int totalSize;
+    uint64_t totalSize;
     int err;
 
     REQUEST_AT_LEAST_SIZE(xRRChangeOutputPropertyReq);
diff --git a/xorg-server-1.19.7/randr/rrproviderproperty.c b/Xserver/randr/rrproviderproperty.c
index b79c17f..90c5a9a 100644
--- a/xorg-server-1.19.7/randr/rrproviderproperty.c
+++ b/Xserver/randr/rrproviderproperty.c
@@ -498,7 +498,7 @@ ProcRRChangeProviderProperty(ClientPtr client)
     char format, mode;
     unsigned long len;
     int sizeInBytes;
-    int totalSize;
+    uint64_t totalSize;
     int err;
 
     REQUEST_AT_LEAST_SIZE(xRRChangeProviderPropertyReq);
diff --git a/xorg-server-1.19.7/record/record.c b/Xserver/record/record.c
index 600d55f..bc72507 100644
--- a/xorg-server-1.19.7/record/record.c
+++ b/Xserver/record/record.c
@@ -2499,7 +2499,7 @@ SProcRecordQueryVersion(ClientPtr client)
 }                               /* SProcRecordQueryVersion */
 
 static int
-SwapCreateRegister(xRecordRegisterClientsReq * stuff)
+SwapCreateRegister(ClientPtr client, xRecordRegisterClientsReq * stuff)
 {
     int i;
     XID *pClientID;
@@ -2509,14 +2509,14 @@ SwapCreateRegister(xRecordRegisterClientsReq * stuff)
     swapl(&stuff->nRanges);
     pClientID = (XID *) &stuff[1];
     if (stuff->nClients >
-        stuff->length - bytes_to_int32(sz_xRecordRegisterClientsReq))
+        client->req_len - bytes_to_int32(sz_xRecordRegisterClientsReq))
         return BadLength;
     for (i = 0; i < stuff->nClients; i++, pClientID++) {
         swapl(pClientID);
     }
     if (stuff->nRanges >
-        stuff->length - bytes_to_int32(sz_xRecordRegisterClientsReq)
-        - stuff->nClients)
+        (client->req_len - bytes_to_int32(sz_xRecordRegisterClientsReq)
+        - stuff->nClients) / bytes_to_int32(sz_xRecordRange))
         return BadLength;
     RecordSwapRanges((xRecordRange *) pClientID, stuff->nRanges);
     return Success;
@@ -2530,7 +2530,7 @@ SProcRecordCreateContext(ClientPtr client)
 
     swaps(&stuff->length);
     REQUEST_AT_LEAST_SIZE(xRecordCreateContextReq);
-    if ((status = SwapCreateRegister((void *) stuff)) != Success)
+    if ((status = SwapCreateRegister(client, (void *) stuff)) != Success)
         return status;
     return ProcRecordCreateContext(client);
 }                               /* SProcRecordCreateContext */
@@ -2543,7 +2543,7 @@ SProcRecordRegisterClients(ClientPtr client)
 
     swaps(&stuff->length);
     REQUEST_AT_LEAST_SIZE(xRecordRegisterClientsReq);
-    if ((status = SwapCreateRegister((void *) stuff)) != Success)
+    if ((status = SwapCreateRegister(client, (void *) stuff)) != Success)
         return status;
     return ProcRecordRegisterClients(client);
 }                               /* SProcRecordRegisterClients */
diff --git a/xorg-server-1.19.7/render/glyph.c b/Xserver/render/glyph.c
index ea865af..41c11b6 100644
--- a/xorg-server-1.19.7/render/glyph.c
+++ b/Xserver/render/glyph.c
@@ -245,10 +245,11 @@ FreeGlyphPicture(GlyphPtr glyph)
     }
 }
 
-static void
+void
 FreeGlyph(GlyphPtr glyph, int format)
 {
     CheckDuplicates(&globalGlyphs[format], "FreeGlyph");
+    BUG_RETURN(glyph->refcnt == 0);
     if (--glyph->refcnt == 0) {
         GlyphRefPtr gr;
         int i;
@@ -354,7 +355,7 @@ AllocateGlyph(xGlyphInfo * gi, int fdepth)
     glyph = (GlyphPtr) malloc(size);
     if (!glyph)
         return 0;
-    glyph->refcnt = 0;
+    glyph->refcnt = 1;
     glyph->size = size + sizeof(xGlyphInfo);
     glyph->info = *gi;
     dixInitPrivates(glyph, (char *) glyph + head_size, PRIVATE_GLYPH);
diff --git a/xorg-server-1.19.7/render/glyphstr.h b/Xserver/render/glyphstr.h
index 2f51bd2..e803455 100644
--- a/xorg-server-1.19.7/render/glyphstr.h
+++ b/Xserver/render/glyphstr.h
@@ -109,6 +109,8 @@ extern GlyphPtr FindGlyph(GlyphSetPtr glyphSet, Glyph id);
 
 extern GlyphPtr AllocateGlyph(xGlyphInfo * gi, int format);
 
+extern void FreeGlyph(GlyphPtr glyph, int format);
+
 extern Bool
  ResizeGlyphSet(GlyphSetPtr glyphSet, CARD32 change);
 
diff --git a/xorg-server-1.19.7/render/render.c b/Xserver/render/render.c
index 3a41e33..53defbb 100644
--- a/xorg-server-1.19.7/render/render.c
+++ b/Xserver/render/render.c
@@ -1076,6 +1076,7 @@ ProcRenderAddGlyphs(ClientPtr client)
 
         if (glyph_new->glyph && glyph_new->glyph != DeletedGlyph) {
             glyph_new->found = TRUE;
+            ++glyph_new->glyph->refcnt;
         }
         else {
             GlyphPtr glyph;
@@ -1168,8 +1169,10 @@ ProcRenderAddGlyphs(ClientPtr client)
         err = BadAlloc;
         goto bail;
     }
-    for (i = 0; i < nglyphs; i++)
+    for (i = 0; i < nglyphs; i++) {
         AddGlyph(glyphSet, glyphs[i].glyph, glyphs[i].id);
+        FreeGlyph(glyphs[i].glyph, glyphSet->fdepth);
+    }
 
     if (glyphsBase != glyphsLocal)
         free(glyphsBase);
@@ -1179,9 +1182,13 @@ ProcRenderAddGlyphs(ClientPtr client)
         FreePicture((void *) pSrc, 0);
     if (pSrcPix)
         FreeScratchPixmapHeader(pSrcPix);
-    for (i = 0; i < nglyphs; i++)
-        if (glyphs[i].glyph && !glyphs[i].found)
-            free(glyphs[i].glyph);
+    for (i = 0; i < nglyphs; i++) {
+        if (glyphs[i].glyph) {
+            --glyphs[i].glyph->refcnt;
+            if (!glyphs[i].found)
+                free(glyphs[i].glyph);
+        }
+    }
     if (glyphsBase != glyphsLocal)
         free(glyphsBase);
     return err;
@@ -2304,6 +2311,9 @@ SProcRenderCompositeGlyphs(ClientPtr client)
 
         i = elt->len;
         if (i == 0xff) {
+            if (buffer + 4 > end) {
+                return BadLength;
+            }
             swapl((int *) buffer);
             buffer += 4;
         }
@@ -2314,12 +2324,18 @@ SProcRenderCompositeGlyphs(ClientPtr client)
                 buffer += i;
                 break;
             case 2:
+                if (buffer + i * 2 > end) {
+                    return BadLength;
+                }
                 while (i--) {
                     swaps((short *) buffer);
                     buffer += 2;
                 }
                 break;
             case 4:
+                if (buffer + i * 4 > end) {
+                    return BadLength;
+                }
                 while (i--) {
                     swapl((int *) buffer);
                     buffer += 4;
diff --git a/xorg-server-1.19.7/xfixes/cursor.c b/Xserver/xfixes/cursor.c
index a150f45..6c8e3a7 100644
--- a/xorg-server-1.19.7/xfixes/cursor.c
+++ b/Xserver/xfixes/cursor.c
@@ -1009,7 +1009,8 @@ ProcXFixesCreatePointerBarrier(ClientPtr client)
 {
     REQUEST(xXFixesCreatePointerBarrierReq);
 
-    REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));
+    REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq,
+                       pad_to_int32(stuff->num_devices * sizeof(CARD16)));
     LEGAL_NEW_RESOURCE(stuff->barrier, client);
 
     return XICreatePointerBarrier(client, stuff);
@@ -1026,7 +1027,8 @@ SProcXFixesCreatePointerBarrier(ClientPtr client)
 
     swaps(&stuff->length);
     swaps(&stuff->num_devices);
-    REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));
+    REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq,
+                       pad_to_int32(stuff->num_devices * sizeof(CARD16)));
 
     swapl(&stuff->barrier);
     swapl(&stuff->window);
diff --git a/xorg-server-1.19.7/xfixes/xfixes.c b/Xserver/xfixes/xfixes.c
index 8b45c53..40f5812 100644
--- a/xorg-server-1.19.7/xfixes/xfixes.c
+++ b/Xserver/xfixes/xfixes.c
@@ -223,7 +223,27 @@ XFixesExtensionInit(void)
         return;
 
     if (XFixesSelectionInit() && XFixesCursorInit() && XFixesRegionInit() &&
+#ifdef TURBOVNC
+        /* Ubuntu 12.04 (precise) shipped a proposed/experimental patch
+         * (https://patchwork.freedesktop.org/patch/8884) to the XFixes
+         * protocol that extended the functionality of pointer barriers.  This
+         * patch was apparently never accepted upstream and was removed in
+         * 13.10 (raring).  Basically everything on Ubuntu 12.04 (probably
+         * 12.10 and 13.04 as well) that uses XFixes, including the window
+         * managers, believes that there are 3 XFixes events, but our server
+         * (and anything else built against the official X.org fixesproto)
+         * believes that there are only 2.  Since X RandR events come
+         * immediately after XFixes events in the sequence, when the TurboVNC
+         * Server sends those events to the window manager and other X clients,
+         * the X clients misinterpret the events, and desktop resizing fails.
+         * Easiest way to work around the issue is to add a slot for the
+         * unofficial XFixes event.  Refer also to
+         * https://lists.x.org/archives/xorg-devel/2012-April/030484.html
+         */
+        (extEntry = AddExtension(XFIXES_NAME, XFixesNumberEvents + 1,
+#else
         (extEntry = AddExtension(XFIXES_NAME, XFixesNumberEvents,
+#endif
                                  XFixesNumberErrors,
                                  ProcXFixesDispatch, SProcXFixesDispatch,
                                  NULL, StandardMinorOpcode)) != 0) {
diff --git a/xorg-server-1.19.7/xkb/xkb.c b/Xserver/xkb/xkb.c
index 678f823..0cd084b 100644
--- a/xorg-server-1.19.7/xkb/xkb.c
+++ b/Xserver/xkb/xkb.c
@@ -152,6 +152,19 @@ static RESTYPE RT_XKBCLIENT;
 #define	CHK_REQ_KEY_RANGE(err,first,num,r)  \
 	CHK_REQ_KEY_RANGE2(err,first,num,r,client->errorValue,BadValue)
 
+static Bool
+_XkbCheckRequestBounds(ClientPtr client, void *stuff, void *from, void *to) {
+    char *cstuff = (char *)stuff;
+    char *cfrom = (char *)from;
+    char *cto = (char *)to;
+
+    return cfrom < cto &&
+           cfrom >= cstuff &&
+           cfrom < cstuff + ((size_t)client->req_len << 2) &&
+           cto >= cstuff &&
+           cto <= cstuff + ((size_t)client->req_len << 2);
+}
+
 /***====================================================================***/
 
 int
@@ -2366,6 +2379,93 @@ SetVirtualModMap(XkbSrvInfoPtr xkbi,
     return (char *) wire;
 }
 
+#define _add_check_len(new) \
+    if (len > UINT32_MAX - (new) || len > req_len - (new)) goto bad; \
+    else len += new
+
+/**
+ * Check the length of the SetMap request
+ */
+static int
+_XkbSetMapCheckLength(xkbSetMapReq *req)
+{
+    size_t len = sz_xkbSetMapReq, req_len = req->length << 2;
+    xkbKeyTypeWireDesc *keytype;
+    xkbSymMapWireDesc *symmap;
+    BOOL preserve;
+    int i, map_count, nSyms;
+
+    if (req_len < len)
+        goto bad;
+    /* types */
+    if (req->present & XkbKeyTypesMask) {
+        keytype = (xkbKeyTypeWireDesc *)(req + 1);
+        for (i = 0; i < req->nTypes; i++) {
+            _add_check_len(XkbPaddedSize(sz_xkbKeyTypeWireDesc));
+            if (req->flags & XkbSetMapResizeTypes) {
+                _add_check_len(keytype->nMapEntries
+                               * sz_xkbKTSetMapEntryWireDesc);
+                preserve = keytype->preserve;
+                map_count = keytype->nMapEntries;
+                if (preserve) {
+                    _add_check_len(map_count * sz_xkbModsWireDesc);
+                }
+                keytype += 1;
+                keytype = (xkbKeyTypeWireDesc *)
+                          ((xkbKTSetMapEntryWireDesc *)keytype + map_count);
+                if (preserve)
+                    keytype = (xkbKeyTypeWireDesc *)
+                              ((xkbModsWireDesc *)keytype + map_count);
+            }
+        }
+    }
+    /* syms */
+    if (req->present & XkbKeySymsMask) {
+        symmap = (xkbSymMapWireDesc *)((char *)req + len);
+        for (i = 0; i < req->nKeySyms; i++) {
+            _add_check_len(sz_xkbSymMapWireDesc);
+            nSyms = symmap->nSyms;
+            _add_check_len(nSyms*sizeof(CARD32));
+            symmap += 1;
+            symmap = (xkbSymMapWireDesc *)((CARD32 *)symmap + nSyms);
+        }
+    }
+    /* actions */
+    if (req->present & XkbKeyActionsMask) {
+        _add_check_len(req->totalActs * sz_xkbActionWireDesc 
+                       + XkbPaddedSize(req->nKeyActs));
+    }
+    /* behaviours */
+    if (req->present & XkbKeyBehaviorsMask) {
+        _add_check_len(req->totalKeyBehaviors * sz_xkbBehaviorWireDesc);
+    }
+    /* vmods */
+    if (req->present & XkbVirtualModsMask) {
+        _add_check_len(XkbPaddedSize(Ones(req->virtualMods)));
+    }
+    /* explicit */
+    if (req->present & XkbExplicitComponentsMask) {
+        /* two bytes per non-zero explicit componen */
+        _add_check_len(XkbPaddedSize(req->totalKeyExplicit * sizeof(CARD16)));
+    }
+    /* modmap */
+    if (req->present & XkbModifierMapMask) {
+         /* two bytes per non-zero modmap component */
+        _add_check_len(XkbPaddedSize(req->totalModMapKeys * sizeof(CARD16)));
+    }
+    /* vmodmap */
+    if (req->present & XkbVirtualModMapMask) {
+        _add_check_len(req->totalVModMapKeys * sz_xkbVModMapWireDesc);
+    }
+    if (len == req_len)
+        return Success;
+bad:
+    ErrorF("[xkb] BOGUS LENGTH in SetMap: expected %ld got %ld\n",
+           len, req_len);
+    return BadLength;
+}
+
+
 /**
  * Check if the given request can be applied to the given device but don't
  * actually do anything..
@@ -2616,6 +2716,11 @@ ProcXkbSetMap(ClientPtr client)
     CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
     CHK_MASK_LEGAL(0x01, stuff->present, XkbAllMapComponentsMask);
 
+    /* first verify the request length carefully */
+    rc = _XkbSetMapCheckLength(stuff);
+    if (rc != Success)
+        return rc;
+
     tmp = (char *) &stuff[1];
 
     /* Check if we can to the SetMap on the requested device. If this
@@ -2854,13 +2959,13 @@ _XkbSetCompatMap(ClientPtr client, DeviceIntPtr dev,
         XkbSymInterpretPtr sym;
         unsigned int skipped = 0;
 
-        if ((unsigned) (req->firstSI + req->nSI) > compat->num_si) {
-            compat->num_si = req->firstSI + req->nSI;
+        if ((unsigned) (req->firstSI + req->nSI) > compat->size_si) {
+            compat->num_si = compat->size_si = req->firstSI + req->nSI;
             compat->sym_interpret = reallocarray(compat->sym_interpret,
-                                                 compat->num_si,
+                                                 compat->size_si,
                                                  sizeof(XkbSymInterpretRec));
             if (!compat->sym_interpret) {
-                compat->num_si = 0;
+                compat->num_si = compat->size_si = 0;
                 return BadAlloc;
             }
         }
@@ -4011,6 +4116,8 @@ _XkbSetNamesCheck(ClientPtr client, DeviceIntPtr dev,
             client->errorValue = _XkbErrCode2(0x04, stuff->firstType);
             return BadAccess;
         }
+        if (!_XkbCheckRequestBounds(client, stuff, tmp, tmp + stuff->nTypes))
+            return BadLength;
         old = tmp;
         tmp = _XkbCheckAtoms(tmp, stuff->nTypes, client->swapped, &bad);
         if (!tmp) {
@@ -4040,6 +4147,8 @@ _XkbSetNamesCheck(ClientPtr client, DeviceIntPtr dev,
         }
         width = (CARD8 *) tmp;
         tmp = (CARD32 *) (((char *) tmp) + XkbPaddedSize(stuff->nKTLevels));
+        if (!_XkbCheckRequestBounds(client, stuff, width, tmp))
+            return BadLength;
         type = &xkb->map->types[stuff->firstKTLevel];
         for (i = 0; i < stuff->nKTLevels; i++, type++) {
             if (width[i] == 0)
@@ -4049,6 +4158,8 @@ _XkbSetNamesCheck(ClientPtr client, DeviceIntPtr dev,
                                                   type->num_levels, width[i]);
                 return BadMatch;
             }
+            if (!_XkbCheckRequestBounds(client, stuff, tmp, tmp + width[i]))
+                return BadLength;
             tmp = _XkbCheckAtoms(tmp, width[i], client->swapped, &bad);
             if (!tmp) {
                 client->errorValue = bad;
@@ -4061,6 +4172,9 @@ _XkbSetNamesCheck(ClientPtr client, DeviceIntPtr dev,
             client->errorValue = 0x08;
             return BadMatch;
         }
+        if (!_XkbCheckRequestBounds(client, stuff, tmp,
+                                    tmp + Ones(stuff->indicators)))
+            return BadLength;
         tmp = _XkbCheckMaskedAtoms(tmp, XkbNumIndicators, stuff->indicators,
                                    client->swapped, &bad);
         if (!tmp) {
@@ -4073,6 +4187,9 @@ _XkbSetNamesCheck(ClientPtr client, DeviceIntPtr dev,
             client->errorValue = 0x09;
             return BadMatch;
         }
+        if (!_XkbCheckRequestBounds(client, stuff, tmp,
+                                    tmp + Ones(stuff->virtualMods)))
+            return BadLength;
         tmp = _XkbCheckMaskedAtoms(tmp, XkbNumVirtualMods,
                                    (CARD32) stuff->virtualMods,
                                    client->swapped, &bad);
@@ -4086,6 +4203,9 @@ _XkbSetNamesCheck(ClientPtr client, DeviceIntPtr dev,
             client->errorValue = 0x0a;
             return BadMatch;
         }
+        if (!_XkbCheckRequestBounds(client, stuff, tmp,
+                                    tmp + Ones(stuff->groupNames)))
+            return BadLength;
         tmp = _XkbCheckMaskedAtoms(tmp, XkbNumKbdGroups,
                                    (CARD32) stuff->groupNames,
                                    client->swapped, &bad);
@@ -4107,9 +4227,14 @@ _XkbSetNamesCheck(ClientPtr client, DeviceIntPtr dev,
                              stuff->nKeys);
             return BadValue;
         }
+        if (!_XkbCheckRequestBounds(client, stuff, tmp, tmp + stuff->nKeys))
+            return BadLength;
         tmp += stuff->nKeys;
     }
     if ((stuff->which & XkbKeyAliasesMask) && (stuff->nKeyAliases > 0)) {
+        if (!_XkbCheckRequestBounds(client, stuff, tmp,
+                                    tmp + (stuff->nKeyAliases * 2)))
+            return BadLength;
         tmp += stuff->nKeyAliases * 2;
     }
     if (stuff->which & XkbRGNamesMask) {
@@ -4117,6 +4242,9 @@ _XkbSetNamesCheck(ClientPtr client, DeviceIntPtr dev,
             client->errorValue = _XkbErrCode2(0x0d, stuff->nRadioGroups);
             return BadValue;
         }
+        if (!_XkbCheckRequestBounds(client, stuff, tmp,
+                                    tmp + stuff->nRadioGroups))
+            return BadLength;
         tmp = _XkbCheckAtoms(tmp, stuff->nRadioGroups, client->swapped, &bad);
         if (!tmp) {
             client->errorValue = bad;
@@ -4310,6 +4438,8 @@ ProcXkbSetNames(ClientPtr client)
     /* check device-independent stuff */
     tmp = (CARD32 *) &stuff[1];
 
+    if (!_XkbCheckRequestBounds(client, stuff, tmp, tmp + 1))
+        return BadLength;
     if (stuff->which & XkbKeycodesNameMask) {
         tmp = _XkbCheckAtoms(tmp, 1, client->swapped, &bad);
         if (!tmp) {
@@ -4317,6 +4447,8 @@ ProcXkbSetNames(ClientPtr client)
             return BadAtom;
         }
     }
+    if (!_XkbCheckRequestBounds(client, stuff, tmp, tmp + 1))
+        return BadLength;
     if (stuff->which & XkbGeometryNameMask) {
         tmp = _XkbCheckAtoms(tmp, 1, client->swapped, &bad);
         if (!tmp) {
@@ -4324,6 +4456,8 @@ ProcXkbSetNames(ClientPtr client)
             return BadAtom;
         }
     }
+    if (!_XkbCheckRequestBounds(client, stuff, tmp, tmp + 1))
+        return BadLength;
     if (stuff->which & XkbSymbolsNameMask) {
         tmp = _XkbCheckAtoms(tmp, 1, client->swapped, &bad);
         if (!tmp) {
@@ -4331,6 +4465,8 @@ ProcXkbSetNames(ClientPtr client)
             return BadAtom;
         }
     }
+    if (!_XkbCheckRequestBounds(client, stuff, tmp, tmp + 1))
+        return BadLength;
     if (stuff->which & XkbPhysSymbolsNameMask) {
         tmp = _XkbCheckAtoms(tmp, 1, client->swapped, &bad);
         if (!tmp) {
@@ -4338,6 +4474,8 @@ ProcXkbSetNames(ClientPtr client)
             return BadAtom;
         }
     }
+    if (!_XkbCheckRequestBounds(client, stuff, tmp, tmp + 1))
+        return BadLength;
     if (stuff->which & XkbTypesNameMask) {
         tmp = _XkbCheckAtoms(tmp, 1, client->swapped, &bad);
         if (!tmp) {
@@ -4345,6 +4483,8 @@ ProcXkbSetNames(ClientPtr client)
             return BadAtom;
         }
     }
+    if (!_XkbCheckRequestBounds(client, stuff, tmp, tmp + 1))
+        return BadLength;
     if (stuff->which & XkbCompatNameMask) {
         tmp = _XkbCheckAtoms(tmp, 1, client->swapped, &bad);
         if (!tmp) {
@@ -4983,7 +5123,7 @@ _GetCountedString(char **wire_inout, ClientPtr client, char **str)
 }
 
 static Status
-_CheckSetDoodad(char **wire_inout,
+_CheckSetDoodad(char **wire_inout, xkbSetGeometryReq *req,
                 XkbGeometryPtr geom, XkbSectionPtr section, ClientPtr client)
 {
     char *wire;
@@ -4994,6 +5134,9 @@ _CheckSetDoodad(char **wire_inout,
     Status status;
 
     dWire = (xkbDoodadWireDesc *) (*wire_inout);
+    if (!_XkbCheckRequestBounds(client, req, dWire, dWire + 1))
+        return BadLength;
+
     any = dWire->any;
     wire = (char *) &dWire[1];
     if (client->swapped) {
@@ -5096,7 +5239,7 @@ _CheckSetDoodad(char **wire_inout,
 }
 
 static Status
-_CheckSetOverlay(char **wire_inout,
+_CheckSetOverlay(char **wire_inout, xkbSetGeometryReq *req,
                  XkbGeometryPtr geom, XkbSectionPtr section, ClientPtr client)
 {
     register int r;
@@ -5107,6 +5250,9 @@ _CheckSetOverlay(char **wire_inout,
 
     wire = *wire_inout;
     olWire = (xkbOverlayWireDesc *) wire;
+    if (!_XkbCheckRequestBounds(client, req, olWire, olWire + 1))
+        return BadLength;
+
     if (client->swapped) {
         swapl(&olWire->name);
     }
@@ -5118,6 +5264,9 @@ _CheckSetOverlay(char **wire_inout,
         xkbOverlayKeyWireDesc *kWire;
         XkbOverlayRowPtr row;
 
+        if (!_XkbCheckRequestBounds(client, req, rWire, rWire + 1))
+            return BadLength;
+
         if (rWire->rowUnder > section->num_rows) {
             client->errorValue = _XkbErrCode4(0x20, r, section->num_rows,
                                               rWire->rowUnder);
@@ -5126,6 +5275,9 @@ _CheckSetOverlay(char **wire_inout,
         row = XkbAddGeomOverlayRow(ol, rWire->rowUnder, rWire->nKeys);
         kWire = (xkbOverlayKeyWireDesc *) &rWire[1];
         for (k = 0; k < rWire->nKeys; k++, kWire++) {
+            if (!_XkbCheckRequestBounds(client, req, kWire, kWire + 1))
+                return BadLength;
+
             if (XkbAddGeomOverlayKey(ol, row,
                                      (char *) kWire->over,
                                      (char *) kWire->under) == NULL) {
@@ -5159,6 +5311,9 @@ _CheckSetSections(XkbGeometryPtr geom,
         register int r;
         xkbRowWireDesc *rWire;
 
+        if (!_XkbCheckRequestBounds(client, req, sWire, sWire + 1))
+            return BadLength;
+
         if (client->swapped) {
             swapl(&sWire->name);
             swaps(&sWire->top);
@@ -5184,6 +5339,9 @@ _CheckSetSections(XkbGeometryPtr geom,
             XkbRowPtr row;
             xkbKeyWireDesc *kWire;
 
+            if (!_XkbCheckRequestBounds(client, req, rWire, rWire + 1))
+                return BadLength;
+
             if (client->swapped) {
                 swaps(&rWire->top);
                 swaps(&rWire->left);
@@ -5195,16 +5353,19 @@ _CheckSetSections(XkbGeometryPtr geom,
             row->left = rWire->left;
             row->vertical = rWire->vertical;
             kWire = (xkbKeyWireDesc *) &rWire[1];
-            for (k = 0; k < rWire->nKeys; k++) {
+            for (k = 0; k < rWire->nKeys; k++, kWire++) {
                 XkbKeyPtr key;
 
+                if (!_XkbCheckRequestBounds(client, req, kWire, kWire + 1))
+                    return BadLength;
+
                 key = XkbAddGeomKey(row);
                 if (!key)
                     return BadAlloc;
-                memcpy(key->name.name, kWire[k].name, XkbKeyNameLength);
-                key->gap = kWire[k].gap;
-                key->shape_ndx = kWire[k].shapeNdx;
-                key->color_ndx = kWire[k].colorNdx;
+                memcpy(key->name.name, kWire->name, XkbKeyNameLength);
+                key->gap = kWire->gap;
+                key->shape_ndx = kWire->shapeNdx;
+                key->color_ndx = kWire->colorNdx;
                 if (key->shape_ndx >= geom->num_shapes) {
                     client->errorValue = _XkbErrCode3(0x10, key->shape_ndx,
                                                       geom->num_shapes);
@@ -5216,14 +5377,14 @@ _CheckSetSections(XkbGeometryPtr geom,
                     return BadMatch;
                 }
             }
-            rWire = (xkbRowWireDesc *) &kWire[rWire->nKeys];
+            rWire = (xkbRowWireDesc *)kWire;
         }
         wire = (char *) rWire;
         if (sWire->nDoodads > 0) {
             register int d;
 
             for (d = 0; d < sWire->nDoodads; d++) {
-                status = _CheckSetDoodad(&wire, geom, section, client);
+                status = _CheckSetDoodad(&wire, req, geom, section, client);
                 if (status != Success)
                     return status;
             }
@@ -5232,7 +5393,7 @@ _CheckSetSections(XkbGeometryPtr geom,
             register int o;
 
             for (o = 0; o < sWire->nOverlays; o++) {
-                status = _CheckSetOverlay(&wire, geom, section, client);
+                status = _CheckSetOverlay(&wire, req, geom, section, client);
                 if (status != Success)
                     return status;
             }
@@ -5266,6 +5427,9 @@ _CheckSetShapes(XkbGeometryPtr geom,
             xkbOutlineWireDesc *olWire;
             XkbOutlinePtr ol;
 
+            if (!_XkbCheckRequestBounds(client, req, shapeWire, shapeWire + 1))
+                return BadLength;
+
             shape =
                 XkbAddGeomShape(geom, shapeWire->name, shapeWire->nOutlines);
             if (!shape)
@@ -5276,21 +5440,27 @@ _CheckSetShapes(XkbGeometryPtr geom,
                 XkbPointPtr pt;
                 xkbPointWireDesc *ptWire;
 
+                if (!_XkbCheckRequestBounds(client, req, olWire, olWire + 1))
+                    return BadLength;
+
                 ol = XkbAddGeomOutline(shape, olWire->nPoints);
                 if (!ol)
                     return BadAlloc;
                 ol->corner_radius = olWire->cornerRadius;
                 ptWire = (xkbPointWireDesc *) &olWire[1];
-                for (p = 0, pt = ol->points; p < olWire->nPoints; p++, pt++) {
-                    pt->x = ptWire[p].x;
-                    pt->y = ptWire[p].y;
+                for (p = 0, pt = ol->points; p < olWire->nPoints; p++, pt++, ptWire++) {
+                    if (!_XkbCheckRequestBounds(client, req, ptWire, ptWire + 1))
+                        return BadLength;
+
+                    pt->x = ptWire->x;
+                    pt->y = ptWire->y;
                     if (client->swapped) {
                         swaps(&pt->x);
                         swaps(&pt->y);
                     }
                 }
                 ol->num_points = olWire->nPoints;
-                olWire = (xkbOutlineWireDesc *) (&ptWire[olWire->nPoints]);
+                olWire = (xkbOutlineWireDesc *)ptWire;
             }
             if (shapeWire->primaryNdx != XkbNoShape)
                 shape->primary = &shape->outlines[shapeWire->primaryNdx];
@@ -5387,12 +5557,15 @@ _CheckSetGeom(XkbGeometryPtr geom, xkbSetGeometryReq * req, ClientPtr client)
         return status;
 
     for (i = 0; i < req->nDoodads; i++) {
-        status = _CheckSetDoodad(&wire, geom, NULL, client);
+        status = _CheckSetDoodad(&wire, req, geom, NULL, client);
         if (status != Success)
             return status;
     }
 
     for (i = 0; i < req->nKeyAliases; i++) {
+        if (!_XkbCheckRequestBounds(client, req, wire, wire + XkbKeyNameLength))
+                return BadLength;
+
         if (XkbAddGeomKeyAlias(geom, &wire[XkbKeyNameLength], wire) == NULL)
             return BadAlloc;
         wire += 2 * XkbKeyNameLength;
@@ -6377,7 +6550,8 @@ ProcXkbGetDeviceInfo(ClientPtr client)
 static char *
 CheckSetDeviceIndicators(char *wire,
                          DeviceIntPtr dev,
-                         int num, int *status_rtrn, ClientPtr client)
+                         int num, int *status_rtrn, ClientPtr client,
+                         xkbSetDeviceInfoReq * stuff)
 {
     xkbDeviceLedsWireDesc *ledWire;
     int i;
@@ -6385,6 +6559,11 @@ CheckSetDeviceIndicators(char *wire,
 
     ledWire = (xkbDeviceLedsWireDesc *) wire;
     for (i = 0; i < num; i++) {
+        if (!_XkbCheckRequestBounds(client, stuff, ledWire, ledWire + 1)) {
+            *status_rtrn = BadLength;
+            return (char *) ledWire;
+        }
+
         if (client->swapped) {
             swaps(&ledWire->ledClass);
             swaps(&ledWire->ledID);
@@ -6412,6 +6591,11 @@ CheckSetDeviceIndicators(char *wire,
             atomWire = (CARD32 *) &ledWire[1];
             if (nNames > 0) {
                 for (n = 0; n < nNames; n++) {
+                    if (!_XkbCheckRequestBounds(client, stuff, atomWire, atomWire + 1)) {
+                        *status_rtrn = BadLength;
+                        return (char *) atomWire;
+                    }
+
                     if (client->swapped) {
                         swapl(atomWire);
                     }
@@ -6423,6 +6607,10 @@ CheckSetDeviceIndicators(char *wire,
             mapWire = (xkbIndicatorMapWireDesc *) atomWire;
             if (nMaps > 0) {
                 for (n = 0; n < nMaps; n++) {
+                    if (!_XkbCheckRequestBounds(client, stuff, mapWire, mapWire + 1)) {
+                        *status_rtrn = BadLength;
+                        return (char *) mapWire;
+                    }
                     if (client->swapped) {
                         swaps(&mapWire->virtualMods);
                         swapl(&mapWire->ctrls);
@@ -6451,7 +6639,9 @@ SetDeviceIndicators(char *wire,
                     unsigned changed,
                     int num,
                     int *status_rtrn,
-                    ClientPtr client, xkbExtensionDeviceNotify * ev)
+                    ClientPtr client,
+                    xkbExtensionDeviceNotify * ev,
+                    xkbSetDeviceInfoReq * stuff)
 {
     xkbDeviceLedsWireDesc *ledWire;
     int i;
@@ -6542,13 +6732,17 @@ SetDeviceIndicators(char *wire,
 }
 
 static int
-_XkbSetDeviceInfo(ClientPtr client, DeviceIntPtr dev,
+_XkbSetDeviceInfoCheck(ClientPtr client, DeviceIntPtr dev,
                   xkbSetDeviceInfoReq * stuff)
 {
     char *wire;
 
     wire = (char *) &stuff[1];
     if (stuff->change & XkbXI_ButtonActionsMask) {
+        int sz = stuff->nBtns * SIZEOF(xkbActionWireDesc);
+        if (!_XkbCheckRequestBounds(client, stuff, wire, (char *) wire + sz))
+            return BadLength;
+
         if (!dev->button) {
             client->errorValue = _XkbErrCode2(XkbErr_BadClass, ButtonClass);
             return XkbKeyboardErrorCode;
@@ -6559,13 +6753,13 @@ _XkbSetDeviceInfo(ClientPtr client, DeviceIntPtr dev,
                              dev->button->numButtons);
             return BadMatch;
         }
-        wire += (stuff->nBtns * SIZEOF(xkbActionWireDesc));
+        wire += sz;
     }
     if (stuff->change & XkbXI_IndicatorsMask) {
         int status = Success;
 
         wire = CheckSetDeviceIndicators(wire, dev, stuff->nDeviceLedFBs,
-                                        &status, client);
+                                        &status, client, stuff);
         if (status != Success)
             return status;
     }
@@ -6576,8 +6770,8 @@ _XkbSetDeviceInfo(ClientPtr client, DeviceIntPtr dev,
 }
 
 static int
-_XkbSetDeviceInfoCheck(ClientPtr client, DeviceIntPtr dev,
-                       xkbSetDeviceInfoReq * stuff)
+_XkbSetDeviceInfo(ClientPtr client, DeviceIntPtr dev,
+                  xkbSetDeviceInfoReq * stuff)
 {
     char *wire;
     xkbExtensionDeviceNotify ed;
@@ -6586,7 +6780,7 @@ _XkbSetDeviceInfoCheck(ClientPtr client, DeviceIntPtr dev,
     ed.deviceID = dev->id;
     wire = (char *) &stuff[1];
     if (stuff->change & XkbXI_ButtonActionsMask) {
-        int nBtns, sz, i;
+	int nBtns, sz, i;
         XkbAction *acts;
         DeviceIntPtr kbd;
 
@@ -6598,6 +6792,8 @@ _XkbSetDeviceInfoCheck(ClientPtr client, DeviceIntPtr dev,
                 return BadAlloc;
             dev->button->xkb_acts = acts;
         }
+        if (stuff->firstBtn + stuff->nBtns > nBtns)
+            return BadValue;
         sz = stuff->nBtns * SIZEOF(xkbActionWireDesc);
         memcpy((char *) &acts[stuff->firstBtn], (char *) wire, sz);
         wire += sz;
@@ -6619,7 +6815,8 @@ _XkbSetDeviceInfoCheck(ClientPtr client, DeviceIntPtr dev,
         int status = Success;
 
         wire = SetDeviceIndicators(wire, dev, stuff->change,
-                                   stuff->nDeviceLedFBs, &status, client, &ed);
+                                   stuff->nDeviceLedFBs, &status, client, &ed,
+                                   stuff);
         if (status != Success)
             return status;
     }
diff --git a/xorg-server-1.19.7/xkb/xkbInit.c b/Xserver/xkb/xkbInit.c
index 9c772f5..8426e30 100644
--- a/xorg-server-1.19.7/xkb/xkbInit.c
+++ b/Xserver/xkb/xkbInit.c
@@ -758,6 +758,30 @@ XkbProcessArguments(int argc, char *argv[], int i)
             return -1;
         }
     }
+#ifdef TURBOVNC
+    else if (strncmp(argv[i], "-xkbcompdir", 11) == 0) {
+        if (++i < argc) {
+#if !defined(WIN32) && !defined(__CYGWIN__)
+            if (getuid() != geteuid()) {
+                LogMessage(X_WARNING,
+                           "-xkbcompdir is not available for setuid X servers\n");
+                return -1;
+            }
+            else
+#endif
+            {
+                if (strlen(argv[i]) < PATH_MAX) {
+                    XkbBinDirectory = argv[i];
+                    return 2;
+                }
+                else {
+                    LogMessage(X_ERROR, "-xkbcompdir pathname too long\n");
+                    return -1;
+                }
+            }
+        }
+    }
+#endif
     else if ((strncmp(argv[i], "-accessx", 8) == 0) ||
              (strncmp(argv[i], "+accessx", 8) == 0)) {
         int j = 1;
diff --git a/xorg-server-1.19.7/xkb/xkbSwap.c b/Xserver/xkb/xkbSwap.c
index ecec63e..4f8c935 100644
--- a/xorg-server-1.19.7/xkb/xkbSwap.c
+++ b/Xserver/xkb/xkbSwap.c
@@ -76,7 +76,7 @@ SProcXkbSelectEvents(ClientPtr client)
         register unsigned bit, ndx, maskLeft, dataLeft, size;
 
         from.c8 = (CARD8 *) &stuff[1];
-        dataLeft = (stuff->length * 4) - SIZEOF(xkbSelectEventsReq);
+        dataLeft = (client->req_len * 4) - SIZEOF(xkbSelectEventsReq);
         maskLeft = (stuff->affectWhich & (~XkbMapNotifyMask));
         for (ndx = 0, bit = 1; (maskLeft != 0); ndx++, bit <<= 1) {
             if (((bit & maskLeft) == 0) || (ndx == XkbMapNotify))
diff --git a/xorg-server-1.19.7/xkb/xkbUtils.c b/Xserver/xkb/xkbUtils.c
index 8975ade..9bc51fc 100644
--- a/xorg-server-1.19.7/xkb/xkbUtils.c
+++ b/Xserver/xkb/xkbUtils.c
@@ -1327,6 +1327,7 @@ _XkbCopyNames(XkbDescPtr src, XkbDescPtr dst)
         }
         else {
             free(dst->names->radio_groups);
+            dst->names->radio_groups = NULL;
         }
         dst->names->num_rg = src->names->num_rg;
 
